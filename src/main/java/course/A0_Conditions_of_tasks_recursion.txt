/*
Реализуйте с помощью рекурсии:
1. возведение числа N в степень M;
2. вычисление суммы цифр числа;
3. расчёт длины списка, для которого разрешена только операция удаления первого элемента pop(0) (и получение длины конечно);
4. проверка, является ли строка палиндромом;
5. печать только чётных значений из списка;
6. печать элементов списка с чётными индексами;
7. нахождение второго максимального числа в списке (с учётом, что максимальных может быть несколько, если они равны).
Второе макс. -- это когда отсортировали список и берём второй элемент (отсчитывая с 1),
если 5,4,3,2,5 например, то второе макс. должно получиться 5.
Равенство или неравенство элементов значения не имеет, т.к. оно никак в условии не оговаривается.

8. поиск всех файлов в заданном каталоге, включая файлы, расположенные в подкаталогах произвольной вложенности.
9. повышенная сложность (можете погуглить).
   Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).
   Например,

   1 = "()"
   2 = "(())" "()()"
   Внешне и внутренне несбалансированные комбинации считаются ошибочными:
   "()))" ")(()" "(()" -- неверно

10. Реализовать следующие операции в классе SimpleTreeNode: (реализация дерева)
    - добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
    - удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
    - последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
    - найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
    - переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
    - подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).
    * Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
    * Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

11. Реализовать в классе BSTNodeTask1: (реализация двоичного дерева поиска)
    - метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
    - метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
    - поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
    - метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

12. Реализовать в классе BSTNode: (реализация обхода в шинирну WideAllNodes(), в глубину DeepAllNodes())
    - Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям,
      так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.
    - Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр,
      принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes()
      реализует соответствующую форму алгоритма поиска в глубину.
    Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (ArrayList в Java).

    Правильная сигнатура:
    ArrayList<BSTNode> WideAllNodes() // Java

13. Реализуйте двоичное дерево поиска в виде массива в классе aBST,
    и сделайте функцию добавления нового узла (фактически, целого ключа)
    и функцию поиска -- не линейно по массиву, а на основе алгоритма из прошлых занятий,
    через условные "узлы" дерева, только ограничьтесь фиксированным размером массива.

    Если всё дерево пройдено до его максимальной глубины и все узлы существуют,
    а совпадения не найдено, поиск возвращает null.
    Если узел (ключ) найден, поиск возвращает его индекс в массиве.
    Если найден незаполненный слот, подходящий для размещения указанного значения
    (другими словами, если очередной "узел", выбранный в процессе поиска, хранит null),
    поиск возвращает его индекс в виде отрицательного значения (например, -12).
    При использовании такого подхода пользователю класса потребуется учесть частный случай,
    когда поиск вернёт 0. В таком случае надо дополнительно проверять, пустое ли дерево.
*/