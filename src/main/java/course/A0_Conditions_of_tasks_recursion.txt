9m8//*
Реализуйте с помощью рекурсии:
1. возведение числа N в степень M;
2. вычисление суммы цифр числа;
3. расчёт длины списка, для которого разрешена только операция удаления первого элемента pop(0) (и получение длины конечно);
4. проверка, является ли строка палиндромом;
5. печать только чётных значений из списка;
6. печать элементов списка с чётными индексами;
7. нахождение второго максимального числа в списке (с учётом, что максимальных может быть несколько, если они равны).
Второе макс. -- это когда отсортировали список и берём второй элемент (отсчитывая с 1),
если 5,4,3,2,5 например, то второе макс. должно получиться 5.
Равенство или неравенство элементов значения не имеет, т.к. оно никак в условии не оговаривается.

8. поиск всех файлов в заданном каталоге, включая файлы, расположенные в подкаталогах произвольной вложенности.
9. повышенная сложность (можете погуглить).
   Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).
   Например,

   1 = "()"
   2 = "(())" "()()"
   Внешне и внутренне несбалансированные комбинации считаются ошибочными:
   "()))" ")(()" "(()" -- неверно

10. Реализовать следующие операции в классе SimpleTreeNode: (реализация дерева)
    - добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
    - удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
    - последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
    - найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
    - переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
    - подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).
    * Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
    * Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

11. Реализовать в классе BSTNodeTask1: (реализация двоичного дерева поиска)
    - метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
    - метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
    - поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
    - метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

12. Реализовать в классе BSTNode: (реализация обхода в шинирну WideAllNodes(), в глубину DeepAllNodes())
    - Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям,
      так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.
    - Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр,
      принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes()
      реализует соответствующую форму алгоритма поиска в глубину.
    Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (ArrayList в Java).

    Правильная сигнатура:
    ArrayList<BSTNode> WideAllNodes() // Java

13. Реализуйте двоичное дерево поиска в виде массива в классе aBST,
    и сделайте функцию добавления нового узла (фактически, целого ключа)
    и функцию поиска -- не линейно по массиву, а на основе алгоритма из прошлых занятий,
    через условные "узлы" дерева, только ограничьтесь фиксированным размером массива.

    Если всё дерево пройдено до его максимальной глубины и все узлы существуют,
    а совпадения не найдено, поиск возвращает null.
    Если узел (ключ) найден, поиск возвращает его индекс в массиве.
    Если найден незаполненный слот, подходящий для размещения указанного значения
    (другими словами, если очередной "узел", выбранный в процессе поиска, хранит null),
    поиск возвращает его индекс в виде отрицательного значения (например, -12).
    При использовании такого подхода пользователю класса потребуется учесть частный случай,
    когда поиск вернёт 0. В таком случае надо дополнительно проверять, пустое ли дерево.

14. Построить сбалансированное двоичное дерево в классе BSTNode:
    Если же нам нужно построить сбалансированное двоичное дерево, состоящее из объектов-узлов,
    то проще воспользоваться алгоритмом построения такого дерева из отсортированного по возрастанию массива.

    Такое построение выполняется тривиально:
    в рекурсивном алгоритме мы выбираем корневой элемент (центральный в отсортированном массиве),
    после чего применяем этот алгоритм к левому и правому поддеревьям (левой и правой частям массива).
    Соответственно, из корневого элемента мы создаём текущий узел, а левым и правым его узлами делаем поддеревья,
    которые возвращают эти два рекурсивных вызова.

    Например, пусть это будет функция F(родитель, диапазон в массиве):
    - создаёте в дереве новый узел A с текущим "корневым" (центральным) значением,
    которому указываете родительский узел (передаётся в параметрах);
    - вызываете рекурсивно F() с диапазоном массива слева от корня и параметром-узлом A как родительским,
    результат этой F() присваиваете левому наследнику A;
    - вызываете рекурсивно F() с диапазоном массива справа от корня и параметром-узлом A как родительским,
    результат этой F() присваиваете правому наследнику A;
    - возвращаете узел A как результат работы F().

    В процессе построения проставьте глубину каждого узла: у корня она равна 0,
    а у каждого потомка на единицу выше, чем у родителя.

    Во-вторых, убедитесь, действительно ли дерево получилось правильным:
    для каждого узла ключ левого потомка должен быть меньше его ключа,
    а ключ правого потомка должен быть больше или равен ключу родителя.

    В-третьих, убедитесь, действительно ли дерево получилось сбалансированным, что определяется тремя правилами:
    - правое поддерево каждого узла сбалансировано;
    - левое поддерево каждого узла сбалансировано;
    - разница между глубинами левого и правого поддеревьев не превышает единицы
    (или, проще говоря, левое и правое поддеревья равны по длинами или отличаются не более чем на одну ветку).

15. Реализуйте Граф в классе SimpleGraph и следующие методы:
    - проверка наличия ребра между вершинами;
    - добавление новой вершины, которая ни с какими другими вершинами не связана
    (тест: вершина имеется, связи с ней отсутствуют);
    - добавление ребра между двумя заданными вершинами
    (тест: до добавления связи между вершинами не было, после добавления появилась);
    - удаление ребра между двумя заданными вершинами
    (тест: до удаления связь между вершинами была, после удаления отсутствует);
    - удаление вершины со всеми её рёбрами
    (тест: до удаления некоторые вершины имеют связи с удаляемой вершиной, после удаления этих связей нету).

    Метод AddVertex() получает параметром значение (целое число),
    которое внутри метода надо преобразовать в объект типа Vertex.
    RemoveVertex() в качестве параметра получает индекс удаляемой вершины.
*/