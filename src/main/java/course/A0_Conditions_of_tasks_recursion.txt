/*
Реализуйте с помощью рекурсии:
1. возведение числа N в степень M;
2. вычисление суммы цифр числа;
3. расчёт длины списка, для которого разрешена только операция удаления первого элемента pop(0) (и получение длины конечно);
4. проверка, является ли строка палиндромом;
5. печать только чётных значений из списка;
6. печать элементов списка с чётными индексами;
7. нахождение второго максимального числа в списке (с учётом, что максимальных может быть несколько, если они равны).
Второе макс. -- это когда отсортировали список и берём второй элемент (отсчитывая с 1),
если 5,4,3,2,5 например, то второе макс. должно получиться 5.
Равенство или неравенство элементов значения не имеет, т.к. оно никак в условии не оговаривается.

8. поиск всех файлов в заданном каталоге, включая файлы, расположенные в подкаталогах произвольной вложенности.
9. повышенная сложность (можете погуглить).
   Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).
   Например,

   1 = "()"
   2 = "(())" "()()"
   Внешне и внутренне несбалансированные комбинации считаются ошибочными:
   "()))" ")(()" "(()" -- неверно

10. Реализовать следующие операции в классе SimpleTreeNode: (реализация дерева)
    - добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
    - удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
    - последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
    - найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
    - переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
    - подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).
    * Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
    * Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

11. Реализовать в классе BSTNode: (реализация двоичного дерева поиска)
    - метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
    - метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
    - поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
    - метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

*/