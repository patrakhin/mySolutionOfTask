9m8//*
Реализуйте с помощью рекурсии:
1. возведение числа N в степень M;
2. вычисление суммы цифр числа;
3. расчёт длины списка, для которого разрешена только операция удаления первого элемента pop(0) (и получение длины конечно);
4. проверка, является ли строка палиндромом;
5. печать только чётных значений из списка;
6. печать элементов списка с чётными индексами;
7. нахождение второго максимального числа в списке (с учётом, что максимальных может быть несколько, если они равны).
Второе макс. -- это когда отсортировали список и берём второй элемент (отсчитывая с 1),
если 5,4,3,2,5 например, то второе макс. должно получиться 5.
Равенство или неравенство элементов значения не имеет, т.к. оно никак в условии не оговаривается.

8. поиск всех файлов в заданном каталоге, включая файлы, расположенные в подкаталогах произвольной вложенности.
9. повышенная сложность (можете погуглить).
   Генерация всех корректных сбалансированных комбинаций круглых скобок (параметр -- количество открывающих скобок).
   Например,

   1 = "()"
   2 = "(())" "()()"
   Внешне и внутренне несбалансированные комбинации считаются ошибочными:
   "()))" ")(()" "(()" -- неверно

10. Реализовать следующие операции в классе SimpleTreeNode_10: (реализация дерева)
    - добавить текущему узлу (первый параметр метода добавления узла) новый узел (второй параметр метода добавления узла) в качестве дочернего (тест: проверяем наличие добавленного узла);
    - удалить некорневой узел (удаляется узел вместе со всем поддеревом) (тест: проверяем отсутствие удалённого узла и его потомков);
    - последовательно обойти всё дерево и сформировать список всех узлов в произвольном порядке;
    - найти список подходящих узлов по заданному значению (тест: проверяем результат с тестовым списком);
    - переместить некорневой узел дочерним узлом в другое место дерева (вместе с его поддеревом), для чего воспользуйтесь предыдущими методами (тест: проверяем, что узел отсутствует там где был исходно и появился в новом месте);
    - подсчитать общее количество узлов в дереве, и количество листьев (тест: проверяем на контрольном дереве количество узлов и листьев).
    * Также напишите метод, который перебирает всё дерево и прописывает каждому узлу его уровень.
    * Придумайте, как лучше организовать поддержку уровня узлов без анализа всего дерева.

11. Реализовать в классе BSTNodeTask1: (реализация двоичного дерева поиска)
    - метод поиска (тест: проверяем поиск отсутствующего ключа в двух вариантах (запрошенный ключ добавляем либо левому, либо правому потомку) и поиск присутствующего ключа);
    - метод добавления нового узла, задаём добавляемый ключ и соответствующее ему значение (тесты: проверяем исходное отсутствие узла по такому ключу в дереве и его наличие после добавления, в двух вариантах -- левым или правым узлом родителя, а также попытку добавления ключа, которое уже имеется в дереве, в таком случае ничего с деревом не делаем);
    - поиск максимального и минимального ключей, начиная с заданного узла (тест, 4 варианта: поиск начиная с корня и поиск начиная с поддерева, ищем максимальный и минимальный ключ);
    - метод удаления узла по его ключу (тест: проверяем исходное наличие узла у родителя, его отсутствие после удаления, и результат работы метода).

12. Реализовать в классе BSTNode_12: (реализация обхода в шинирну WideAllNodes(), в глубину DeepAllNodes())
    - Реализуйте дополнительный метод обхода дерева WideAllNodes() без параметров для класса из занятия по двоичным деревьям,
      так, чтобы он реализовывал алгоритм поиска в ширину, начиная с корня.
    - Реализуйте дополнительный метод обхода дерева DeepAllNodes(), начиная с корня, которому задаётся один целый параметр,
      принимающий значения 0 (in-order), 1 (post-order) и 2 (pre-order). В зависимости от этого параметра метод DeepAllNodes()
      реализует соответствующую форму алгоритма поиска в глубину.
    Эти алгоритмы формируют на выходе стандартный список из объектов BSTNode (ArrayList в Java).

    Правильная сигнатура:
    ArrayList<BSTNode> WideAllNodes() // Java

13. Реализуйте двоичное дерево поиска в виде массива в классе aBST_13,
    и сделайте функцию добавления нового узла (фактически, целого ключа)
    и функцию поиска -- не линейно по массиву, а на основе алгоритма из прошлых занятий,
    через условные "узлы" дерева, только ограничьтесь фиксированным размером массива.

    Если всё дерево пройдено до его максимальной глубины и все узлы существуют,
    а совпадения не найдено, поиск возвращает null.
    Если узел (ключ) найден, поиск возвращает его индекс в массиве.
    Если найден незаполненный слот, подходящий для размещения указанного значения
    (другими словами, если очередной "узел", выбранный в процессе поиска, хранит null),
    поиск возвращает его индекс в виде отрицательного значения (например, -12).
    При использовании такого подхода пользователю класса потребуется учесть частный случай,
    когда поиск вернёт 0. В таком случае надо дополнительно проверять, пустое ли дерево.

14. Построить сбалансированное двоичное дерево в классе BSTNode:
    Если же нам нужно построить сбалансированное двоичное дерево, состоящее из объектов-узлов,
    то проще воспользоваться алгоритмом построения такого дерева из отсортированного по возрастанию массива.

    Такое построение выполняется тривиально:
    в рекурсивном алгоритме мы выбираем корневой элемент (центральный в отсортированном массиве),
    после чего применяем этот алгоритм к левому и правому поддеревьям (левой и правой частям массива).
    Соответственно, из корневого элемента мы создаём текущий узел, а левым и правым его узлами делаем поддеревья,
    которые возвращают эти два рекурсивных вызова.

    Например, пусть это будет функция F(родитель, диапазон в массиве):
    - создаёте в дереве новый узел A с текущим "корневым" (центральным) значением,
    которому указываете родительский узел (передаётся в параметрах);
    - вызываете рекурсивно F() с диапазоном массива слева от корня и параметром-узлом A как родительским,
    результат этой F() присваиваете левому наследнику A;
    - вызываете рекурсивно F() с диапазоном массива справа от корня и параметром-узлом A как родительским,
    результат этой F() присваиваете правому наследнику A;
    - возвращаете узел A как результат работы F().

    В процессе построения проставьте глубину каждого узла: у корня она равна 0,
    а у каждого потомка на единицу выше, чем у родителя.

    Во-вторых, убедитесь, действительно ли дерево получилось правильным:
    для каждого узла ключ левого потомка должен быть меньше его ключа,
    а ключ правого потомка должен быть больше или равен ключу родителя.

    В-третьих, убедитесь, действительно ли дерево получилось сбалансированным, что определяется тремя правилами:
    - правое поддерево каждого узла сбалансировано;
    - левое поддерево каждого узла сбалансировано;
    - разница между глубинами левого и правого поддеревьев не превышает единицы
    (или, проще говоря, левое и правое поддеревья равны по длинами или отличаются не более чем на одну ветку).

15. Реализуйте Граф в классе SimpleGraph и следующие методы:
    - проверка наличия ребра между вершинами;
    - добавление новой вершины, которая ни с какими другими вершинами не связана
    (тест: вершина имеется, связи с ней отсутствуют);
    - добавление ребра между двумя заданными вершинами
    (тест: до добавления связи между вершинами не было, после добавления появилась);
    - удаление ребра между двумя заданными вершинами
    (тест: до удаления связь между вершинами была, после удаления отсутствует);
    - удаление вершины со всеми её рёбрами
    (тест: до удаления некоторые вершины имеют связи с удаляемой вершиной, после удаления этих связей нету).

    Метод AddVertex() получает параметром значение (целое число),
    которое внутри метода надо преобразовать в объект типа Vertex.
    RemoveVertex() в качестве параметра получает индекс удаляемой вершины.

16. Чётные деревья и леса (SimpleTreeNode16)
    Задание -- найти лес, состоящий из чётных деревьев,
    из которого удалено максимально возможное количество рёбер.
    Чётное дерево -- это дерево с чётным количеством вершин.
    На входе имеется обычное (не бинарное) дерево,
    и требуется найти максимально возможное количество рёбер,
    которое можно из него удалить так, чтобы в результате получался лес из чётных деревьев.

    Расширьте класс SimpleTree из первого занятия методом EvenTrees(), который на основе текущего готового дерева формирует максимально возможный результирующий список пар вершин, для которых надо разорвать связь (удалить соответствующее ребро). Список линейный, i-й элемент -- это родительская вершина, i+1 - й элемент -- это её наследник. Между ними связь и разрывается.
    Элементы здесь -- это вершины, объекты класса SimpleTreeNode.

17. Поиск пути в графе (обход в глубину) SimpleGraph_17

    Алгоритм Depth-first search (dfs) работает так:
    0) Очищаем все дополнительные структуры данных:
    делаем стек пустым, а все вершины графа отмечаем как непосещённые (см. далее).

    1) Выбираем текущую вершину X. Для начала работы это будет исходная вершина А.

    2) Фиксируем вершину X как посещённую.
    Для этого в класс Vertex надо добавить, например, флажок hit, который принимает значение True,
    если вершина была таким образом посещёна.

    3) Помещаем вершину X в стек.

    4) Ищем среди смежных вершин вершины X целевую вершину Б.
    Если она найдена, записываем её в стек и возвращаем сам стек как результат работы (путь из А в Б).
    Если целевой вершины среди смежных нету, то выбираем среди смежных такую вершину,
    которая ещё не была посещена. Если такая вершина найдена, делаем её текущей X и переходим к п. 2.

    5) Если непосещённых смежных вершин более нету, удаляем из стека верхний элемент.
    Если стек пуст, то прекращаем работу и информируем, что путь не найден.
    В противном случае делаем текущей вершиной X верхний элемент стека, помечаем его как посещённый,
    и после чего переходим к п. 4.

    Расширьте класс SimpleGraph из позапрошлого занятия методом DepthFirstSearch(),
    который получает в качестве параметров два узла Vertex (начальный и конечный) --
    узлы задаются индексами-позициями в списке vertex18 -- и возвращает список узлов,
    представляющий собой путь из начального узла в конечный.
    Список будет пустым, если пути не существует.

    Реализуйте этот алгоритм с помощью стека.

18. Поиск пути в графе (обход в ширину) SimpleGraph_18
    Этому алгоритму потребуется очередь.
    Алгоритм Breadth-first search (bfs) работает так:
    0) Очищаем все дополнительные структуры данных: делаем очередь пустой,
    а все вершины графа отмечаем как непосещённые.
    1) Выбираем текущую вершину X. Для начала работы это будет исходная вершина А.
    Фиксируем вершину А как посещённую.
    2) Из всех смежных с X вершин выбираем любую (например первую) непосещённую.
    Если выбранная вершина равна искомой, значит цель найдена,
    заканчиваем работу (остаётся только сформировать до неё путь, если это требуется).
    Если таких вершин нету, проверяем очередь:
    Если очередь пуста, заканчиваем работу (путь до цели не найден).
    Иначе извлекаем из очереди очередной элемент, делаем его текущим X,
    и переходим обратно к данному п.2.
    3) Помечаем найденную смежную вершину как посещённую, помещаем в очередь. Переходим к п.2.
    Таким образом, данный алгоритм сперва заносит все ближайшие к текущему узлу вершины в очередь,
    а потом выбирает их по одной, и дальше также сканирует смежные с ними.
    В очереди у нас просто хранятся вершины, смежные с которыми вершины ещё не исследованы до конца.
    Проблема данного подхода в том, что он не хранит, в отличие от поиска в глубину,
    текущий маршрут из исходной вершины к текущей.
    Реализуйте поиск в ширину и реализуйте способ хранения текущего пути.
    В таком случае поиск в ширину будет гарантировать,
    что найденный путь будет оптимальным (минимальным) - ведь мы, согласно концепции очереди,
    сначала сканируем все без исключения вершины, ближайшие к исходной вершине,
    затем - удалённые на два ребра, затем - на три, и т. д.
    Расширьте класс SimpleGraph методом BreadthFirstSearch(),
    который получает в качестве параметров индексы в массиве vertex18 двух узлов (начальный и конечный)
    и возвращает список узлов, представляющий собой путь из начального узла в конечный,
    либо пустой список, если пути не существует.

19. Расширьте класс SimpleGraph_19  методом WeakVertices(), который возвращает список узлов,
    не входящих ни в один треугольник в графе.
*/