Задача 1.
RestoredSalaryTable

Восстановление таблицы зарплат
Взятый на прошлой неделе на работу джуниор Олег случайно удалил в базе таблицу, 
в которой хранилась информация о взаимосвязях учётных номеров сотрудников и их зарплат. 
Только вы помните на память алгоритм этой связи; требуется срочно восстановить таблицу 
и сформировать ведомость зарплат в точном соответствии зарплаты и номера сотрудника.
Номера сотрудников -- это целые положительные числа. 
Они некоторым особо упорядоченным способом хранятся в списке сотрудников; 
номер каждого сотрудника уникален, повторяющихся нету. 
Пример списка сотрудников: [50, 1, 1024]
Зарплаты -- тоже целые положительные числа. Они хранятся в отдельном списке зарплат, 
по размеру равном списку сотрудников, но могут повторяться по значениям. 
Пример списка зарплат: [20000, 100000, 90000]
Известно, что список сотрудников однозначно соответствует списку зарплат, 
если отсортировать по возрастанию список номеров и список зарплат. 
То есть номеру 50 соответствует зарплата 90000, номеру 1 - 20000, номеру 1024 -- 100000.
Ваша задача -- перестроить список зарплат, не трогая список номеров, так, 
чтобы соблюдалось правильное соответствие номер-зарплата. 
В данном примере список зарплат должен получиться таким: [90000, 20000, 100000]
________________________________________
Функция
int [] SynchronizingTables(int N, int [] ids, int [] salary)
получает параметром N длину обоих массивов. 
Параметр ids -- массив, содержащий номера сотрудников, 
параметр salary -- массив, содержащий зарплаты.
Возвращает функция массив, содержащий переупорядоченные зарплаты.
/////////////////////////////////////////////////////////////////////////////////////////

Задача 2.
InitialImpulse

Безумный Макс
Безумный Макс Рокатански, офицер Главного Силового Патруля, ремонтирует свой восьмицилиндровый Перехватчик, 
чтобы продолжить погоню за Ночным Ездоком. Не дайте Ездоку добраться до банды Потрошителей, 
помогите Максу правильно настроить машину патруля.
Бортовой софт Перехватчика генерирует телеметрический массив -- неповторяющиеся целые числа в диапазоне от 0 до 255, 
общим количеством N (длина массива), которое всегда нечётно. 
В общем случае эти значения в массиве будут случайно перемешаны.
1 <= N <= 127
Для достижения максимального количества оборотов двигателю требуется корректный стартовый импульс. 
Он представляет собой массив, центральным элементом которого будет максимальное его значение, 
все левые элементы упорядочены по возрастанию (причём первый левый элемент -- самый минимальный в массиве), 
а все правые -- по убыванию.
Например, на входе массив из семи элементов, N=7:
1 2 3 4 5 6 7
Эти элементы могут быть случайно перемешаны.
На выходе должно быть:
1 2 3 7 6 5 4
Функция
int [] MadMax(int N, int [] Tele)
получает на вход массив Tele из N чисел, и возвращает результирующий массив-импульс.
/////////////////////////////////////////////////////////////////////////////////////////

Задача 3.
UnlockPhone

Разблокировка мобильных телефонов
Код блокировки мобильных телефонов не умеют взламывать даже спецслужбы, 
однако хакерская группировка Анонимусы-80 добралась до исходников операционной системы, 
и выяснила способ его почти мгновенного взлома.
Оказывается, достаточно лишь посчитать длину линии, рисуемой в процессе взлома кода, 
после чего округлить её до пятого знака, и нажать пальцем на соответствующие цифры, 
пропуская нули, как телефон разблокируется.
Раскладка точек блокировки:
Ломаная линия разблокировки представляет собой последовательность цифр от 1 до 9, 
соответствующих точкам на этой картинке, причем гарантируется, 
что от точки переход совершается только к её ближайшим соседям (нету перепрыгиваний, например из точки 8 в точку 5).
Расстояние между точками по вертикали или горизонтали считается единичным.
На рисунке представлена такая последовательность: 1 2 3 4 5 6 2 7 8 9
Её длина приблизительно равняется 1 + 1 + 1 + 1 + 1 + 1.41.. + 1.41.. + 1 + 1 = 9.82843
(точность требуется пять цифр после запятой)
Результат: строка "982843"
Если бы результат получился, например, 10.012, то результирующая строка получилась бы "112" (все нули удаляются).
________________________________________
Функция
string PatternUnlock(int N, int [] hits)
получает параметром N длину массива с кодами разблокировки, 
а сам массив hits содержит последовательность кодов разблокировки -- номера точек в диапазоне от 1 до 9.
Последовательность задаётся только шагами между соседними точками, 
программно искать "длинные" пути не нужно.
Возвращает функция строку.
/////////////////////////////////////////////////////////////////////////////////////////

Задача 4.
BracketBalance

Определение баланса скобок
/////////////////////////////////////////////////////////////////////////////////////////

Задача 5.
WhiteWalkers

Белые Ходоки

Белые Ходоки снова готовят свою армию мертвецов для очередного штурма Стены. 
Но они подкрадываются к ней хитростью, стараясь незаметно затесаться среди мирных жителей окрестных деревень.
Для этого Ходоки принимают обличье крестьян, однако становятся различимыми, 
когда группируются в тройки -- температура вокруг них при этом понижается на 10 градусов.
Вы возглавляете Железный Трон Семи Королевств и посылаете разведчиков выявить всех врагов.
Дайте им подробные инструкции по определению вражеских сил в каждой деревне.
________________________________________
Каждая деревня задаётся ASCII-строкой (возможно, пустой).
В ней могут быть числа (жители, разбредшиется по полям), 
но только из одного символа (цифры от 0 до 9). То есть подряд несколько цифр не могут следовать.
Если в такой строке между каждой парой чисел (цифр), сумма которых равна 10, 
насчитываются ровно три Ходока (символ "="), значит, Ходоки успешно выявлены.
________________________________________
Функция
bool white_walkers(string village)
получает параметром village строку, описывающую одну деревню, 
и возвращает true, если в ней выявляются все Ходоки.
Например:
"axxb6===4xaf5===eee5" => true
"5==ooooooo=5=5" => false
"abc=7==hdjs=3gg1=======5" => true
"aaS=8" => false
"9===1===9===1===9" => true
/////////////////////////////////////////////////////////////////////////////////////////

Задача 6.
PurchaseSum

Сумма к оплате
В магазине акция: «купи три одинаковых товара и заплати только за два».
Конечно, каждый купленный товар может участвовать лишь в одной акции. Акцию можно использовать многократно.
Например, если будут куплены 77 товаров одного вида по цене 22 за штуку и 55 товаров другого вида по цене 33 за штуку,
то вместо 7⋅2+5⋅37⋅2+5⋅3 надо будет оплатить 5⋅2+4⋅3=225⋅2+4⋅3=22.
Считая, что одинаковые цены имеют только одинаковые товары, найдите сумму к оплате.
Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
Входные данные
В первой строке записано целое число t� (1≤t≤1041≤�≤104) — количество наборов входных данных.
Далее записаны наборы входных данных. Каждый начинается строкой,
которая содержит n� (1≤n≤2⋅1051≤�≤2⋅105) — количество купленных товаров.
Следующая строка содержит их цены p1,p2,…,pn�1,�2,…,�� (1≤pi≤1041≤��≤104).
Если цены двух товаров одинаковые, то надо считать, что это один и тот товар.
Гарантируется, что сумма значений n� по всем тестам не превосходит 2⋅1052⋅105.
Выходные данные
Выведите t� целых чисел — суммы к оплате для каждого из наборов входных данных.

Пример
входные данные
6
12
2 2 2 2 2 2 2 3 3 3 3 3
12
2 3 2 3 2 2 3 2 3 2 2 3
1
10000
9
1 2 3 1 2 3 1 2 3
6
10000 10000 10000 10000 10000 10000
6
300 100 200 300 200 300
выходные данные
22
22
10000
12
40000
/////////////////////////////////////////////////////////////////////////////////////////

Задача 7.
CoupleOfPeople

Парное программирование
В компании работает n� разработчиков, где n� — четное число.
Сумасшедший менеджер решил разбить всех разработчиков на команды по два человека.
Для этого он составил список всех разработчиков и назначил каждому из них номер по списку (от 11 до n�)
и значение ai�� — уровень мастерства i�-го в списке разработчика.
Очередную команду он составляет следующим образом:
1.	первый разработчик в команде тот, кто идет первым в списке;
2.	ему в пару подбирается такой, что разница их уровней минимальна
(то есть минимально значение |ai−aj||��−��|, где |x||�| — это модуль числа x�);
если таких кандидатов несколько, то выбирается из них тот, кто находится раньше в списке;
3.	эти два разработчика образуют команду и удаляются из списка.
Например, если массив a� равен [2,1,3,1,1,4][2,1,3,1,1,4], то формирование команд будет происходить следующим образом:
1.	назначим разработчикам номера [1,2,3,4,5,6][1,2,3,4,5,6] в соответствии с их положением в списке,
первый среди них имеет номер 11, его уровень мастерства a1=2�1=2,
подходящими (с минимальной абсолютной разностью) являются разработчики с номерами 2,3,4,52,3,4,5,
первый среди них 22, таким образом первая команда — это разработчики с номерами 11 и 22;
2.	оставшиеся разработчики теперь имеют номера [3,4,5,6][3,4,5,6], первый среди них 33, его уровень a3=3�3=3,
разработчик с минимальной абсолютной разностью только один (номер 66),
таким образом команда — разработчики с номерами 33 и 66;
3.	оставшиеся разработчики имеют номера [4,5][4,5], первый среди них 44, его уровень a4=1�4=1,
остался только разработчик с номером 55, таким образом третья команда — разработчики с номерами 44 и 55.
Ваша задача — помочь сумасшедшему менеджеру промоделировать процесс разбиения на команды.
Обратите внимание, что команды должны быть выведены в порядке, описанном выше в условии.

Входные данные
Первая строка содержит одно целое число t� (1≤t≤501≤�≤50) — количество наборов входных данных.
Первая строка каждого набора содержит одно целое число n� (2≤n≤502≤�≤50; n� четное) — количество разработчиков.
Вторая строка содержит n� целых чисел a1,a2,…,an�1,�2,…,�� (1≤ai≤1001≤��≤100),
где ai�� — уровень мастерства i�-го разработчика.
Выходные данные
Для каждого набора входных данных выведите n2�2 строк,
i�-я строка должна содержать пару чисел — номер первого и второго разработчика в i�-й команде в порядке,
описанном в условии.
Выводите пустую строку между выводами для наборов входных данных.

Пример
входные данные
3
6
2 1 3 1 1 4
2
5 5
8
1 4 2 5 4 2 6 3
выходные данные
1 2
3 6
4 5

1 2

1 3
2 5
4 7
6 8
Примечание
Первый набор входных данных из примера разобран в условии задачи.
/////////////////////////////////////////////////////////////////////////////////////////

Задача 8.
SortTable

Электронная таблица
Вам необходимо написать часть функциональности обработки сортировок в электронных таблицах.
Задана прямоугольная таблица n×m�×� (n� строк по m� столбцов) из целых чисел.
Если кликнуть по заголовку i�-го столбца, то строки таблицы пересортируются таким образом,
что в этом столбце значения будут идти по неубыванию (то есть возрастанию или равенству).
При этом, если у двух строк одинаковое значение в этом столбце, то относительный порядок строк не изменится.

Рассмотрим пример.
В этом примере сначала клик был совершен по второму столбцу, затем по первому и, наконец, по третьему.
Заметим, что если кликнуть подряд два раза в один столбец,
то после второго клика таблица не изменится (в момент второго клика она уже отсортирована по этому столбцу).
Обработайте последовательность кликов и выведите состояние таблицы после всех кликов.
Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
Входные данные
В первой строке записано целое число t� (1≤t≤1001≤�≤100) — количество наборов входных данных в файле.
Далее следуют описания наборов, перед каждым из них записана пустая строка.
В первой строке набора записаны два целых числа n� и m� (1≤n,m≤301≤�,�≤30) — количество строк и столбцов в таблице.
Далее следуют n� строк по m� целых чисел в каждой — начальное состояние таблицы. Все элементы таблицы от 11 до 100100.
Затем входные данные содержат строку с один целым числом k� (1≤k≤301≤�≤30) — количество кликов.
Следующая строка содержит k� целых чисел c1,c2,…,ck�1,�2,…,�� (1≤ci≤m1≤��≤�) — номера столбцов,
по которым были осуществлены клики. Клики даны в порядке их совершения.
Выходные данные
Для каждого набора входных данных выведите n� строк по m� чисел в каждой — итоговое состояние таблицы.
После каждого набора выходных данных выводите дополнительный перевод строки.

Пример
входные данные
3

4 3
3 4 1
2 2 5
2 4 2
2 2 1
3
2 1 3

3 1
100
9
10
2
1 1

3 3
2 11 72
99 11 13
2 8 13
5
2 3 2 1 2
выходные данные
2 2 1
3 4 1
2 4 2
2 2 5

9
10
100

2 8 13
2 11 72
99 11 13
/////////////////////////////////////////////////////////////////////////////////////////

Задача 9.
